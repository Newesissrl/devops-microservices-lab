# GitOps Production Deployment Workflow
# Highly controlled production deployment with multiple approval gates and canary deployment
# Demonstrates GitOps principle: Production deployments require strict validation and approval

name: Deploy to Production

# GitOps Trigger: Manual production deployment only
on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Staging-validated image tag to promote (e.g., main-abc1234)'
        required: true
        type: string
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        default: 'canary'
        type: choice
        options:
        - canary
        - blue-green
        - rolling

# Strict permissions for production deployment
permissions:
  contents: read
  id-token: write
  deployments: write

# Environment variables for production deployment
env:
  AWS_REGION: us-west-2
  ECS_CLUSTER: expenses-app-prod
  ENVIRONMENT: prod

jobs:
  # Job 1: Pre-Production Validation
  # GitOps: Extensive validation before production deployment
  validate:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ github.event.inputs.image_tag }}
      deployment_strategy: ${{ github.event.inputs.deployment_strategy }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Configure AWS credentials for validation
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole-prod
          aws-region: ${{ env.AWS_REGION }}

      # Validate image exists and was tested in staging
      - name: Validate staging deployment
        run: |
          IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          echo "Validating production readiness for: $IMAGE_TAG"
          
          # Verify images exist in registry
          SERVICES=("backend" "frontend" "processor")
          for service in "${SERVICES[@]}"; do
            IMAGE="ghcr.io/${{ github.repository }}/$service:$IMAGE_TAG"
            docker manifest inspect "$IMAGE" > /dev/null
            echo "âœ… $service image validated: $IMAGE"
          done

      # Security scan for production images
      - name: Production security scan
        run: |
          echo "Running production security validation..."
          
          # Check for critical vulnerabilities in production images
          SERVICES=("backend" "frontend" "processor")
          for service in "${SERVICES[@]}"; do
            IMAGE="ghcr.io/${{ github.repository }}/$service:${{ github.event.inputs.image_tag }}"
            echo "Security scanning: $IMAGE"
            
            # This would integrate with your security scanning tool
            # For demo purposes, we'll simulate the check
            echo "âœ… Security scan passed for $service"
          done

      # Validate staging health before production deployment
      - name: Validate staging health
        run: |
          echo "Validating staging environment health..."
          
          # Get staging ALB endpoint
          STAGING_ALB=$(aws elbv2 describe-load-balancers \
            --names expenses-app-staging-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          STAGING_ENDPOINT="https://$STAGING_ALB"
          
          # Test staging health
          if curl -f -s "$STAGING_ENDPOINT" > /dev/null; then
            echo "âœ… Staging environment is healthy"
          else
            echo "âŒ Staging environment is unhealthy - blocking production deployment"
            exit 1
          fi

  # Job 2: Infrastructure Drift Check
  # GitOps: Ensure production infrastructure is in desired state
  infrastructure-check:
    runs-on: ubuntu-latest
    needs: validate
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole-prod
          aws-region: ${{ env.AWS_REGION }}

      # Install SOPS for secrets management
      - name: Install SOPS
        run: |
          curl -LO https://github.com/mozilla/sops/releases/latest/download/sops-v3.8.1.linux.amd64
          sudo mv sops-v3.8.1.linux.amd64 /usr/local/bin/sops
          sudo chmod +x /usr/local/bin/sops

      # Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      # Check for infrastructure drift
      - name: Infrastructure drift detection
        working-directory: devops/terraform/environments/prod
        run: |
          # Initialize and check for drift
          terraform init
          
          # Run plan to detect any drift
          terraform plan -detailed-exitcode > drift-check.txt 2>&1
          PLAN_EXIT_CODE=$?
          
          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "âœ… No infrastructure drift detected"
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "âš ï¸ Infrastructure drift detected:"
            cat drift-check.txt
            echo "Please review and apply infrastructure changes before deployment"
            exit 1
          else
            echo "âŒ Terraform plan failed"
            cat drift-check.txt
            exit 1
          fi

  # Job 3: Production Deployment with Approval
  # GitOps: Controlled deployment with multiple approval gates
  deploy:
    runs-on: ubuntu-latest
    needs: [validate, infrastructure-check]
    
    # Production environment requires manual approval
    environment:
      name: production
      url: ${{ steps.endpoint.outputs.application_url }}
    
    strategy:
      matrix:
        service: [backend, frontend, processor]
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole-prod
          aws-region: ${{ env.AWS_REGION }}

      # Login to GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Canary Deployment Strategy
      - name: Canary deployment
        if: needs.validate.outputs.deployment_strategy == 'canary'
        id: canary
        run: |
          echo "Starting canary deployment for ${{ matrix.service }}..."
          
          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition expenses-${{ matrix.service }}-prod \
            --query 'taskDefinition' \
            --output json)
          
          # Update with new image
          NEW_IMAGE="ghcr.io/${{ github.repository }}/${{ matrix.service }}:${{ needs.validate.outputs.image_tag }}"
          
          echo $TASK_DEF | jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)' \
            > new-task-def.json
          
          # Register new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          # Start canary deployment (10% traffic initially)
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service expenses-${{ matrix.service }} \
            --task-definition "$NEW_TASK_DEF_ARN" \
            --deployment-configuration "minimumHealthyPercent=90,maximumPercent=110"
          
          echo "âœ… Canary deployment initiated for ${{ matrix.service }}"

      # Blue-Green Deployment Strategy
      - name: Blue-green deployment
        if: needs.validate.outputs.deployment_strategy == 'blue-green'
        run: |
          echo "Starting blue-green deployment for ${{ matrix.service }}..."
          
          # Implementation would create a complete parallel environment
          # For this demo, we'll use the standard ECS deployment
          
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition expenses-${{ matrix.service }}-prod \
            --query 'taskDefinition' \
            --output json)
          
          NEW_IMAGE="ghcr.io/${{ github.repository }}/${{ matrix.service }}:${{ needs.validate.outputs.image_tag }}"
          
          echo $TASK_DEF | jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)' \
            > new-task-def.json
          
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service expenses-${{ matrix.service }} \
            --task-definition "$NEW_TASK_DEF_ARN" \
            --force-new-deployment
          
          echo "âœ… Blue-green deployment initiated for ${{ matrix.service }}"

      # Wait for initial deployment
      - name: Wait for deployment
        run: |
          echo "Waiting for ${{ matrix.service }} deployment to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services expenses-${{ matrix.service }}
          
          echo "âœ… ${{ matrix.service }} deployment completed"

  # Job 4: Production Health Monitoring
  # GitOps: Continuous monitoring during deployment
  monitor:
    runs-on: ubuntu-latest
    needs: deploy
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole-prod
          aws-region: ${{ env.AWS_REGION }}

      # Get production endpoint
      - name: Get production endpoint
        id: endpoint
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names expenses-app-prod-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          echo "alb-dns=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "application_url=https://$ALB_DNS" >> $GITHUB_OUTPUT

      # Monitor deployment health
      - name: Monitor deployment health
        run: |
          ENDPOINT="https://${{ steps.endpoint.outputs.alb-dns }}"
          
          echo "Monitoring production deployment health..."
          
          # Monitor for 5 minutes
          for i in {1..10}; do
            echo "Health check $i/10..."
            
            # Test application health
            if curl -f -s "$ENDPOINT" > /dev/null; then
              echo "âœ… Health check $i passed"
            else
              echo "âŒ Health check $i failed"
              
              # If we're in canary mode and health checks fail, rollback
              if [ "${{ needs.validate.outputs.deployment_strategy }}" = "canary" ]; then
                echo "ðŸ”„ Initiating automatic rollback due to health check failure"
                # Rollback logic would go here
                exit 1
              fi
            fi
            
            # Wait 30 seconds between checks
            sleep 30
          done
          
          echo "âœ… Production health monitoring completed successfully"

      # Performance validation
      - name: Production performance validation
        run: |
          ENDPOINT="https://${{ steps.endpoint.outputs.alb-dns }}"
          
          echo "Validating production performance..."
          
          # Performance test
          TOTAL_TIME=0
          REQUESTS=20
          
          for i in $(seq 1 $REQUESTS); do
            RESPONSE_TIME=$(curl -o /dev/null -s -w "%{time_total}" "$ENDPOINT")
            TOTAL_TIME=$(echo "$TOTAL_TIME + $RESPONSE_TIME" | bc -l)
            echo "Request $i: ${RESPONSE_TIME}s"
          done
          
          AVG_TIME=$(echo "scale=3; $TOTAL_TIME / $REQUESTS" | bc -l)
          echo "Average response time: ${AVG_TIME}s"
          
          # Fail if average response time > 2 seconds
          if (( $(echo "$AVG_TIME > 2.0" | bc -l) )); then
            echo "âŒ Performance validation failed: Average response time too high"
            exit 1
          fi
          
          echo "âœ… Production performance validation passed"

  # Job 5: Canary Traffic Increase (if canary deployment)
  # GitOps: Gradual traffic increase for canary deployments
  canary-promote:
    runs-on: ubuntu-latest
    needs: [validate, deploy, monitor]
    if: needs.validate.outputs.deployment_strategy == 'canary'
    
    # Additional approval for full canary promotion
    environment:
      name: production-canary-promote
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole-prod
          aws-region: ${{ env.AWS_REGION }}

      # Promote canary to full traffic
      - name: Promote canary to 100%
        run: |
          echo "Promoting canary deployment to 100% traffic..."
          
          # In a real implementation, this would gradually increase traffic
          # 10% -> 25% -> 50% -> 100% with monitoring at each step
          
          SERVICES=("backend" "frontend" "processor")
          for service in "${SERVICES[@]}"; do
            echo "Promoting $service to full traffic..."
            
            # Force new deployment to complete the rollout
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service expenses-$service \
              --force-new-deployment
            
            # Wait for service to stabilize
            aws ecs wait services-stable \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services expenses-$service
            
            echo "âœ… $service promoted to 100% traffic"
          done

  # Job 6: Post-Deployment Validation
  # GitOps: Final validation and documentation
  post-deployment:
    runs-on: ubuntu-latest
    needs: [validate, deploy, monitor]
    if: always() && needs.deploy.result == 'success'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole-prod
          aws-region: ${{ env.AWS_REGION }}

      # Install SOPS for configuration updates
      - name: Install SOPS
        run: |
          curl -LO https://github.com/mozilla/sops/releases/latest/download/sops-v3.8.1.linux.amd64
          sudo mv sops-v3.8.1.linux.amd64 /usr/local/bin/sops
          sudo chmod +x /usr/local/bin/sops

      # Update production configuration
      - name: Update production configuration
        run: |
          CONFIG_FILE="config/environments/prod/app-config.json"
          
          if [ -f "$CONFIG_FILE" ]; then
            jq -r 'to_entries[] | select(.key != "_comment" and .key != "_gitops_principle") | "/expenses-app/prod/\(.key) \(.value | tostring)"' $CONFIG_FILE | \
            while read param_name param_value; do
              aws ssm put-parameter \
                --name "$param_name" \
                --value "$param_value" \
                --type "String" \
                --overwrite || true
            done
            
            echo "âœ… Production configuration updated"
          fi

      # Create deployment record
      - name: Create deployment record
        run: |
          echo "Creating deployment record..."
          
          # Create deployment tag in Git
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          TAG_NAME="prod-deploy-$(date +%Y%m%d-%H%M%S)"
          git tag -a "$TAG_NAME" -m "Production deployment: ${{ needs.validate.outputs.image_tag }}"
          
          echo "âœ… Deployment record created: $TAG_NAME"

      # Final deployment summary
      - name: Deployment summary
        run: |
          echo "## ðŸš€ Production Deployment Completed" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Production" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ needs.validate.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Strategy**: ${{ needs.validate.outputs.deployment_strategy }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Time**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation**: ${{ needs.validate.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment**: ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring**: ${{ needs.monitor.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Production Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Application URL**: https://${{ steps.endpoint.outputs.alb-dns }}" >> $GITHUB_STEP_SUMMARY