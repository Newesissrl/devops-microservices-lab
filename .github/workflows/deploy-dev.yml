# GitOps Development Deployment Workflow
# Automatically deploys to development environment when code is merged to develop branch
# Demonstrates GitOps principle: Git push triggers automated deployment

name: Deploy to Development

# GitOps Trigger: Automatic deployment on develop branch changes
# This implements the "push-based" GitOps model where Git changes trigger deployments
on:
  push:
    branches: [develop]
    paths:
      - 'packages/**'           # Application code changes
      - 'devops/ecs/**'        # ECS configuration changes
      - 'config/environments/dev/**'  # Environment config changes

# Required permissions for AWS deployment
permissions:
  contents: read
  id-token: write  # Required for OIDC authentication with AWS

# Environment variables for deployment
env:
  AWS_REGION: us-west-2
  ECS_CLUSTER: expenses-app-dev
  ENVIRONMENT: dev

jobs:
  # Job 1: Deploy Infrastructure Changes (if any)
  # GitOps Principle: Infrastructure as Code changes are deployed first
  infrastructure:
    runs-on: ubuntu-latest
    outputs:
      infrastructure_changed: ${{ steps.changes.outputs.terraform }}
    
    steps:
      # Check what files changed to determine if infrastructure deployment is needed
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit to detect changes

      # Detect infrastructure changes
      - name: Detect infrastructure changes
        id: changes
        run: |
          if git diff --name-only HEAD~1 HEAD | grep -E '^devops/terraform/'; then
            echo "terraform=true" >> $GITHUB_OUTPUT
            echo "Infrastructure changes detected"
          else
            echo "terraform=false" >> $GITHUB_OUTPUT
            echo "No infrastructure changes"
          fi

      # Configure AWS credentials using OIDC (more secure than access keys)
      - name: Configure AWS credentials
        if: steps.changes.outputs.terraform == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole-dev
          aws-region: ${{ env.AWS_REGION }}

      # Install SOPS for secrets decryption
      - name: Install SOPS
        if: steps.changes.outputs.terraform == 'true'
        run: |
          curl -LO https://github.com/mozilla/sops/releases/latest/download/sops-v3.8.1.linux.amd64
          sudo mv sops-v3.8.1.linux.amd64 /usr/local/bin/sops
          sudo chmod +x /usr/local/bin/sops

      # Setup Terraform for infrastructure deployment
      - name: Setup Terraform
        if: steps.changes.outputs.terraform == 'true'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      # Deploy infrastructure changes
      - name: Deploy infrastructure
        if: steps.changes.outputs.terraform == 'true'
        working-directory: devops/terraform/environments/dev
        run: |
          # GitOps: Terraform plan and apply for infrastructure changes
          # SOPS automatically decrypts secrets.enc.tfvars when Terraform runs
          terraform init
          terraform plan -out=tfplan
          terraform apply tfplan

  # Job 2: Deploy Application Services
  # GitOps Principle: Application deployment follows infrastructure
  deploy-services:
    runs-on: ubuntu-latest
    needs: infrastructure
    
    strategy:
      # Deploy services in parallel for faster deployment
      matrix:
        service: [backend, frontend, processor]
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole-dev
          aws-region: ${{ env.AWS_REGION }}

      # Login to GitHub Container Registry to pull images
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Update ECS Task Definition with new image
      # GitOps: Declarative task definition updated with new image tag
      - name: Update task definition
        id: task-def
        run: |
          # Get the current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition expenses-${{ matrix.service }} \
            --query 'taskDefinition' \
            --output json)
          
          # Update image with commit SHA tag
          NEW_IMAGE="ghcr.io/${{ github.repository }}/${{ matrix.service }}:develop-${{ github.sha }}"
          
          # Create new task definition with updated image
          echo $TASK_DEF | jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)' \
            > new-task-def.json
          
          # Register new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "task-def-arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT

      # Update ECS Service with new task definition
      # GitOps: Service update triggers rolling deployment
      - name: Deploy to ECS
        run: |
          # Update ECS service with new task definition
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service expenses-${{ matrix.service }} \
            --task-definition ${{ steps.task-def.outputs.task-def-arn }} \
            --force-new-deployment

      # Wait for deployment to complete
      # GitOps: Verify deployment success before proceeding
      - name: Wait for deployment
        run: |
          echo "Waiting for service to reach stable state..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services expenses-${{ matrix.service }}
          
          echo "✅ ${{ matrix.service }} deployment completed successfully"

  # Job 3: Update Configuration
  # GitOps: Apply configuration changes from Git
  update-config:
    runs-on: ubuntu-latest
    needs: deploy-services
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole-dev
          aws-region: ${{ env.AWS_REGION }}

      # Update AWS Parameter Store with new configuration
      # GitOps: Configuration stored in Git, applied to AWS
      - name: Update configuration
        run: |
          # Update application configuration in Parameter Store
          CONFIG_FILE="config/environments/dev/app-config.json"
          
          if [ -f "$CONFIG_FILE" ]; then
            # Parse configuration and update Parameter Store
            jq -r 'to_entries[] | select(.key != "_comment" and .key != "_gitops_principle") | "/expenses-app/dev/\(.key) \(.value | tostring)"' $CONFIG_FILE | \
            while read param_name param_value; do
              aws ssm put-parameter \
                --name "$param_name" \
                --value "$param_value" \
                --type "String" \
                --overwrite || true
            done
            
            echo "✅ Configuration updated in Parameter Store"
          fi

  # Job 4: Post-Deployment Verification
  # GitOps: Automated testing to verify deployment success
  verify-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-services, update-config]
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole-dev
          aws-region: ${{ env.AWS_REGION }}

      # Get ALB endpoint for testing
      - name: Get application endpoint
        id: endpoint
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names expenses-app-dev-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          echo "alb-dns=$ALB_DNS" >> $GITHUB_OUTPUT

      # Health check verification
      - name: Verify deployment health
        run: |
          ENDPOINT="http://${{ steps.endpoint.outputs.alb-dns }}"
          
          echo "Testing application health at $ENDPOINT"
          
          # Test frontend
          if curl -f "$ENDPOINT" > /dev/null 2>&1; then
            echo "✅ Frontend is healthy"
          else
            echo "❌ Frontend health check failed"
            exit 1
          fi
          
          # Test backend API
          if curl -f "$ENDPOINT/api/" > /dev/null 2>&1; then
            echo "✅ Backend API is healthy"
          else
            echo "❌ Backend API health check failed"
            exit 1
          fi

      # Notify deployment success
      - name: Deployment notification
        run: |
          echo "## 🚀 Development Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Development" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Application URL**: http://${{ steps.endpoint.outputs.alb-dns }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Time**: $(date)" >> $GITHUB_STEP_SUMMARY